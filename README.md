# MyCC
开始跟随北大的一个编译原理实验进行简单的编译器编写  
应该是一个长期的大项目
## part 1 实现基本的编译器
### 小补充
- 使用 `echo $?` 查看上一条命令的返回值，  
  使用 > 重定向输出（返回值），使用 < 间接输入  
- 调试器：使用 gdb gcc 两个程序进行命令行调试  
  先使用 gcc 编译，使用 `gdb ./test.exe` 进行调试  
  命令行命令基本与 IDE 中调试功能一致，区别在于直接用命令行进行，更方便  
  特别是 print 大法不好用时，段错误时  
- 使用一些编译工具 flex，bison 等，以及写 makefile
### 编译中的一些工具
- 本质上，写一个编译器的工作量级以周为单位，并大多涉及大量 enum 型的代码工作  
  这是因为 C语言本质上有其复杂性，有相当多关键字等，虽然循序渐进的写，还是十分复杂  
  不过因为是逻辑性的工作，存在生成方法与生成器  
- flex，bison 是词法、语法生成器，是根据词法分割规则、语法规则生成分割器的  
  举例，将60行与200行的规则生成了几千行的实际分割器程序  
  编译这些代码就能得到类似 gcc 的编译器程序  
  这是因为编译器本质上算简单语言的处理工具，从语言学的角度研究、实现  
- LLVM IR 是一种跨平台、跨语言的中间表示方法，即什么语言都可以用这种表达  
  不同编译器的前端是语言相关的，词法分解的规则不同，后端是平台相关的，与硬件机器码有关  
  但是 gcc 比 llvm 古老的多，不使用这个 ir，所以这时多使用 clang 相关，基于 llvm
- 编译中较难的部分是与屏幕等交互的过程，就是输入输出部分    
  作为例子，test.ll 通过 `clang -S -emit-llvm test.c -o test.ll` 生成  
  文件结构为头部信息、全局常量、函数实现、外部函数声明、属性组、元数据等  
  其中已经涉及对栈中具体数据位的管理，需要考虑寄存器变化，又达不到具体运算实现的程度    
  比如进位寄存器、超强类型等, alloca 在栈上分配内存，load 加载到寄存器   
  getelementptr inbounds 获取结构成员的地址，call 调用函数  
- 得到的 risc 精简指令集汇编也可以通过 clang 继续汇编、链接  
  常用的汇编大多是 x86，这里可以用 x86 或 risc-v，后者通过 clang 汇编、链接  
  再在一个模拟器 qemu 上运行，否则架构不同，无法运行
- 编译的前端、中端、后端指的是词法分析、语法分析，生成 AST 抽象语法树；将 AST 变成  
  IR，同时进行优化；将 ir 转成相应的汇编代码。注意这只是编译过程，之后，还需要进行汇编与链接  
  才能形成可执行文件，为了适配 risc-V，其他文件也需要编译成 risc-V，通过 clang 编译  
  作为复习，编译时也会进行类型检查、进行报错
- 其中用到一些上下文无关文法生成形式等计算理论的工具  
  比如得到一个程序对应的上下文无关文法（扩展巴克斯范式），从开始推至完整程序  
  复习一下，上下文无关文法有终结词、开始符号、空、或、若干等符号  
  大写标识符(表示常量) 与 ""(表示逻辑) 作为终结词，{}表示若干个   
  一般函数名与数字常量等用大写，最终对应到内存的地址，关键字表示逻辑  
  本质上 手写的递归下降分析器就是这种范式的解释器  
  Flex 处理终结词识别部分，Bison 处理式子的生成过程  

### .l .y 文件
- 两个配置文件的格式差不多，是生成解释器的配置文件，如下：
  ```lex
  // 这里写一些选项, 可以控制 Flex/Bison 的某些行为
  %{
  // 这里写一些全局的代码
  // 生成解释器 C/C++ 文件，其中用到的头文件和一些全局声明/定义
  %}
  // 这里写一些 Flex/Bison 相关的定义
  // 对于 Flex, 这里可以定义某个符号对应的正则表达式
  // 对于 Bison, 这里可以定义终结符/非终结符的类型
  %%
  // 这里写 Flex/Bison 的规则描述
  // 对于 Flex, 这里写的是 lexer 扫描到某个 token 后做的操作
  // 对于 Bison, 这里写的是 parser 遇到某种语法规则后做的操作
  %%
  // 这里写一些用户自定义的代码
  // 比如你希望在生成的 C/C++ 文件里定义一个函数, 做一些辅助工作
  // 你同时希望在之前的规则描述里调用你定义的函数
  // 那么, 你可以把 C/C++ 的函数定义写在这里, 声明写在文件开头
  ```
- 需要注意的 flex 匹配机制：最长匹配，前面优先匹配
- flex 处的注释需要仔细，最好不要有
- 具体如何写，看示例文件即可，并未完全理解  
  $n 表示第 n 个符号的语义值，像是递归调用，$$表示当前符号语义，类似返回 return
- 总体来说，flex 分为配置，开头，表达式定义、规则四部分  
  配置较固定，开头主要看规则区用到哪些库，引入即可  
  表达式定义就是 align 的一些内容，关键就是会正则表达式  
  规则区较多，正则表达式或自定义符号对应代码块，相当于读到该表达式的行为  
- bison 分为开头，引用，定义区，规则  
  引用是生成解释器需要，开头是解释过程需要，定义区定义各符号的实际类型  
  规则区定义语法的派生规则以及附带的具体行为

### ast部分
- 管理一个树状节点，加一些节点头文件即可  
  实际管理过程在 .y 文件中处理，都继承 base 即可  
  复杂节点在 hpp 文件中定义，引入 .y 文件  
  为了使生成的解释器、规则本身知道，前两个模块都需要加 include  
  相应的规则中各变量类型也要更改





